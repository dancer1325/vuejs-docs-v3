---
footer: false
---

# Introduction {#introduction}

- goal 
  - Vue 3

- Vue 2
  - [EOL](https://v2.vuejs.org/eol/).
  - [Migration Guide v2 - v3](https://v3-migration.vuejs.org/)

## The Progressive Framework {#the-progressive-framework}

- Vue
  - 's goal
    - flexible
    - incrementally adoptable
    - Reason: ðŸ§  web is extremely diverse & vary drasticallðŸ§ 
  - use cases 
- Enhancing static HTML without a build step
- Embedding as Web Components on any page
- Single-Page Application (SPA)
- Fullstack / Server-Side Rendering (SSR)
- Jamstack / Static Site Generation (SSG)
- Targeting desktop, mobile, WebGL, and even the terminal



Despite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue "The Progressive Framework": it's a framework that can grow with you and adapt to your needs.

## Single-File Components {#single-file-components}

- **Single-File Component** (**SFC**) OR `*.vue` files
  - == HTML-like file format
  - == component's logic (JS) + template (HTML) + styles (CSS)
  - allows
    - authoring Vue components
      - == Vue will handle ALL the build tools setup -- for -- you
  - uses
    - | build-tool-enabled Vue projects


 Here's the previous example, written in SFC format:

<div class="options-api">

```vue
<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>

<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>

<style scoped>
button {
  font-weight: bold;
}
</style>
```

</div>
<div class="composition-api">

```vue
<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>

<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>

<style scoped>
button {
  font-weight: bold;
}
</style>
```

</div>

 

## API Styles {#api-styles}

- allows
  - authoring Vue components

### Options API {#options-api}

- component's logic is defined -- vÃ­a -- object of options
  - _Example:_ `data`, `methods`, and `mounted`
  - Options' properties are exposed | `this` inside functions
    - == points -- to the -- component instance

- "component instance"
  - MAIN concept 
  - == class-based model == OOP language

```vue
<script>
export default {
  // Properties returned from data() become reactive state
  // and will be exposed on `this`.
  data() {
    return {
      count: 0
    }
  },

  // Methods are functions that mutate state and trigger updates.
  // They can be bound as event handlers in templates.
  methods: {
    increment() {
      this.count++
    }
  },

  // Lifecycle hooks are called at different stages
  // of a component's lifecycle.
  // This function will be called when the component is mounted.
  mounted() {
    console.log(`The initial count is ${this.count}.`)
  }
}
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

[Vue Playground](https://play.vuejs.org/#eNptkMFqxCAQhl9lkB522ZL0HNKlpa/Qo4e1ZpLIGhUdl5bgu9es2eSyIMio833zO7NP56pbRNawNkivHJ25wV9nPUGHvYiaYOYGoK7Bo5CkbgiBBOFy2AkSh2N5APmeojePCkDaaKiBt1KnZUuv3Ky0PppMsyYAjYJgigu0oEGYDsirYUAP0WULhqVrQhptF5qHQhnpcUJD+wyQaSpUd/Xp9NysVY/yT2qE0dprIS/vsds5Mg9mNVbaDofL94jZpUgJXUKBCvAy76ZUXY53CTd5tfX2k7kgnJzOCXIF0P5EImvgQ2olr++cbRE4O3+t6JxvXj0ptXVpye1tvbFY+ge/NJZt)

- use cases
  - NOT use build tools

### Composition API {#composition-api}

- component's logic is defined -- via -- imported API functions
- uses
  - | SFCs,
    - Composition API is used with [`<script setup>`](/api/sfc-script-setup)

- `setup` attribute
  - == hint / Vue performs compile-time transforms 
  - allow us 
    - use Composition API / less boilerplate
 For example, imports and top-level variables / functions declared in `<script setup>` are directly usable in the template.

Here is the same component, with the exact same template, but using Composition API and `<script setup>` instead:

```vue
<script setup>
import { ref, onMounted } from 'vue'

// reactive state
const count = ref(0)

// functions that mutate state and trigger updates
function increment() {
  count.value++
}

// lifecycle hooks
onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

[Try it in the Playground](https://play.vuejs.org/#eNpNkMFqwzAQRH9lMYU4pNg9Bye09NxbjzrEVda2iLwS0spQjP69a+yYHnRYad7MaOfiw/tqSliciybqYDxDRE7+qsiM3gWGGQJ2r+DoyyVivEOGLrgRDkIdFCmqa1G0ms2EELllVKQdRQa9AHBZ+PLtuEm7RCKVd+ChZRjTQqwctHQHDqbvMUDyd7mKip4AGNIBRyQujzArgtW/mlqb8HRSlLcEazrUv9oiDM49xGGvXgp5uT5his5iZV1f3r4HFHvDprVbaxPhZf4XkKub/CDLaep1T7IhGRhHb6WoTADNT2KWpu/aGv24qGKvrIrr5+Z7hnneQnJu6hURvKl3ryL/ARrVkuI=)

- [Composition API FAQ](/guide/extras/composition-api-faq)
- use cases
  - if you want to build full applications -> Composition API + Single-File Components
  - low comolexity scenarios

### Which to Choose? {#which-to-choose}

- Options API vs Composition API
  - valid BOTH | common use cases
  - DIFFERENT interfaces / powered -- by -- SAME underlying system
  - ðŸ‘€Options API is implemented | Composition APIðŸ‘€
  - SAME fundamental concepts 

 It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups.

The Composition API is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic.


## Still Got Questions? {#still-got-questions}

- [FAQ](/about/faq)
